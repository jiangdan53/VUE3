# vue3 
 - 新的脚手架搭建工具 Vite 
   1. vite 是什么 
     vite 是一个新的脚手架搭建工具 可以全局安装也可以使用 npm cerate vite@latest 项目名称 --template vue 这是搭建一个vue的指令
     - 是什么？ vite 是基于ES module 模块化的开发服务器 通过nodejs 搭建一个本地的开发服务器 将我们的所有模块视为一块静态的资源 
     - 作为一个开发者服务器 vite搭建的项目需要在支持ES module 模块解析的新时代浏览器的支持 不然则访问的资源无法解析 也就看不到页面  
   2. vite 和 vue/cli的区别以及优势和劣势是什么
    - vite 的优势 运行快 不需要打包 请求那个模块就对那个模块打包 所有的模块都是通过ES module 来传输给浏览器让其解析 
    - 在vite启动的项目中 没有运行时的打包过程 他是直接其启动一个静态资源服务器 在页面中我们所引用的script 标签中使用其type属性将其设置为module 从而得到浏览器的支持 在浏览器中解析 并且将所有的组将通过请求的方式给到浏览器，换句话说这个过程类似于ajax请求 我们需要用到啥就请求那一部分的数据 从而省略了 打包的过程 提升运行速度 并且带有缓存功能第一次运行后将缓存结果 以达到提升下一次运行速度上的提升 
    - vite 的劣势 在我们的开发中 需要使用支持es module 解析的浏览器来进行开发 不能很好的向下兼容 对于初学者不太友好，不支持Commonjs(浏览器不支持解析Commonjs)
    - vue/cli 是通过webpack来进行打包的一款脚手架打包工具 他的工作流程是先进行预编译然后整合所有模块并且通过babel编译后 启动一个服务器来给到我们的浏览器 此过程在大型项目中很耗时 
    - vue/cli 优点 所有的项目在我们的本地服务器中展示出来的都是通过babel编译后的结构 具有良好的向下兼容性 对于新手开发者来说更容易理解 可以适用于更多低版本的浏览器 
    - vue/cli 缺点 当我们在实际开发中 一旦我们改动的组件 涉及的其他模块太多会导致我们的编译过程漫长 等待时间过长 同样在我们每天运行项目来说也是一个很耗时的过程  没有缓存的功能 每次都需要相同的时间 
    - vite 和vue/cli 的区别 
     1. 第一是在运行时的速度 能够节省很多的时间 
     2. 第二时在我们热跟新方面 vue/cli每次更新都需要 从新编译依赖文件 而vite只针对改动的文件进行更新 这一点上也会使得vite的效率远远高于vue/cli 
     3. 在文件或组件的引用上面 我们需要在vite搭建的项目中带上组件的后缀名称 而vue/cli则不需要 
     4. 在项目中对于Commonjs的支持vite不如vue/cli 
# vue3 效率提升点 
  1. 静态提升 
   - vue2 
     1. 在vue2 中我们的模板中的所有元素都会通过一个redenr函数来生成我们的虚拟节点 这样一来如果某个节点中的静态节点数过多会导致解析模板耗时过长 每次动态数据改动都需要去解析静态模板 重复的创建静态节点的虚拟dom 
      - vue3  在 vue3 中将标记我们的静态节点 将其提升到render函数的顶部 第一次运行时创建一个变量来保存他 后面使用直接使用变量 就不需要重复的创建虚拟节点 从而实现性能的提升 
  2. 预字符串化 
    预字符串和静态提升的区别在于 静态提升是根据模板将每个节点使用createVNode创建一个js对象的过程而预字符串化是在虚拟节点更新时的虚拟dom树对比过程  
   - vue 2 
     1. 在我们的模板中的静态节点数 会重复的进行虚拟dom创建 导致树形结构很庞大不利于更新时对比两棵树的虚拟dom 影响性能
   - vue3 
     1. vue3会将我们模板中的节点找到查看该节点上是否具有动态的属性或者数据来决定是否需要在虚拟dom树跟新时是否需要对比来提升 
     2. 它同样的会将 静态的节点在render函数顶部创建_createStaticVNode('')一个预字符串形式的一个虚拟dom结构 然后将其放入到render中 会将动态的节点放入到数组中 等待跟新时去遍历对比 
  3. 缓存事件处理函数 
   - 此优化 vue2在与每次更新时都需要在元素对象上去反复的执行创建事件处理函数 每次执行都会消耗一部分的性能 
   - vue3 中在render函数中会有第二个参数作为缓存数据 而这个缓存数据最开始是没有的 当我们的元素第一次被创建的时候会给其数组赋值 当第二次更新时直接只用内存则不需要再去执行创建事件处理函数的事件  
  4. Block Tree 
   - vue2 
     1. 在vue2中 我们通常在数据更新时需要从根节点开始对比虚拟dom树而 这样会导致我们在对比时会做一些无用功 将那些没有改变的虚拟dom也一起对比了
   - vue3 
     1. 在vue3 中运行时会收集元素中的动态数据依赖 在使用动态数据的元素中去标记使用动态数据的节点打上标记并且记录下来 而去忽略那些静态的节点 这样大大减少了 虚拟dom更新时的对比时间
  5. PathFlag 
    - 这个点是根据前面的虚拟dom来做进一步的优化 在我们标记的后面会具体的记录当前元素上需要更新的属性或者节点 减少不必要的计算过程 根据标记法来实现动态渲染 
